<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>htuc-build</title>
		<meta name="description" content="A pure HTML reveal.js presentation">
		<meta name="author" content="Your Name">

		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Gasoek+One&display=swap" rel="stylesheet">

		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.css">
		<link rel="stylesheet" href="../theme-dracula.css">
		<link rel="stylesheet" href="../codestyle.css">

		<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/highlight.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/notes/notes.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/math/math.js"></script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>편찬을 편찬하십시오</h2>
				</section>

				<section>
					<h2>학습 목표</h2>
					<ul>
						<li class="fragment fade-in">
							변환기와 연결기의 역할을 알 수 있다
						</li>
						<li class="fragment fade-in">
							프로그램의 제작 과정을 엿볼 수 있다
						</li>
						<li class="fragment fade-in">
							프로그램의 제작 과정을 자동화할 수 있다
						</li>
					</ul>
				</section>

				<section>
					<section>
						<h2>변환기</h2>
						<p><small>Compiler</small></p>
						<ul>
							<li>개인연산기는 기게어가 필요해요.</li>
							<li>이런 고수준 언어들은 단순함이 없어요...</li>
							<li>그들은 순간의 변환기로 빠른 기계어를 원합니다.</li>
							<li>컴파일하기</li>
						</ul>
					</section>

					<section>
						<h2>고수준 언어</h2>
						<p>
						<small>retz.c</small><br/>
						<small>C90</small><br/>
						</p>
						<pre><code class="language-c" data-trim data-noescape data-line-numbers>
							<script type="text/template">
								/** 
								 * retz라는 이름을 가진 간단한 함수.
								 * 0을 반환한다.
								 * 
								 * 이식성이 높다.
								 * > 명령어를 바꾸지 않더라도 같은 명령어로 많은 기계에서 동작시킬 수 있다.
								 */
								int retz(void) {
									return 0;
								}
							</script>
						</code></pre>
					</section>

					<section>
						<h2>변환 과정</h2>
						<br/>
						<pre>
						<code class="language-make" data-trim data-noescape data-line-numbers="|1-5|7-8|">
						<script type="text/template">
							# 고수준 언어를 목적 언어로 변환
							# 연결이 되기 이전이라 실행은 불가능하다
							gcc retz.c	\
								-c				\ # 연결기 사용 금지
								-o retz.o

							# 목적 언어를 저수준 언어로 변환
							objdump -d retz.o > retz.s
						</script>
						</code>
						</pre>
					</section>

					<section>
						<h2>저수준 언어</h2>
						<p>
						<small>retz.s</small><br/>
						<small>x86 assembly</small><br/>
						</p>
						<pre>
						<code class="language-x86asm" data-trim data-noescape data-line-numbers>
						<script type="text/template">
							; 위 고수준 언어와 동작이 같음
							; 인간이 읽기 편한 언어 중 가장 저수준이다.
							; 기계에 종속적이다. (특정 기계에서만 유효하다)

							retz:
								push    %rbp
								mov     %rbp, %rsp
								mov     %eax, 0x0
								pop     %rbp
								ret						
						</script>
						</code>
						</pre>
					</section>
				</section>

				<section>
					<section>
						<h2>연결기</h2>
						<p><small>Linker</small><br/></p>
						<ul>
							<li>생산된 목적 언어를 엮는다.</li>
							<li>사용할 수 있는 프로그램을 만든다.</li>
						</ul>
					</section>

					<section>
						<p>main.c</p>
						<pre><code 
						class="language-c" 
						data-trim data-noescape
						data-line-numbers="|1-2|5-6|"
						>
							<script type="text/template">
								/** 어딘가에 retz라는 이름의 함수가 있다. */
								extern int retz(void);

								int main(void) {
									/** retz의 반환값을 그대로 반환한다. */
									return retz();
								}
							</script>
						</code></pre>

						<p>retz.c</p>
						<pre><code class="language-c" data-trim data-noescape data-line-numbers>
							<script type="text/template">
								/** 
								 * retz라는 이름을 가진 간단한 함수.
								 * 0을 반환한다.
								 *
								 * 맨 바깥에 있으므로 다른 파일은 이 함수를 볼 수 있다.
								 */
								int retz(void) {
									return 0;
								}
							</script>
						</code></pre>
					</section>

					<section>
						<h2>연결기 사용</h2><br/>
						<pre><code class="language-sh" data-trim data-noescape data-line-numbers="|1-4|6-7|">
							<script type="text/template">
								# 변환기 사용
								# 파일 수만큼 사용하는 경우가 일반적이다.
								gcc main.c -c -o main.c.o
								gcc retz.c -c -o retz.c.o

								# 두 목적 언어를 사용하여 프로그램을 엮는다.
								gcc main.c.o retz.c.o -o out
							</script>
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>근데 생각해야 할 거 많음</h2>
					</section>
					<section>
						<ul>
							<li>포함 위치?</li>
							<li class="fragment fade-in">컴파일러?</li>
							<li class="fragment fade-in">저 명령어를 하나 하나 따로 쳐야 해?</li>
							<li class="fragment fade-in">명령어 실수하면?</li>
							<li class="fragment fade-in">코드를 나누고 싶으면?</li>
							<li class="fragment fade-in">나중에 정리는 어떻게?</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h2>편찬기</h2>
						<p><small>Builder</small></p>
						<p>특: 그 과정을 프로그래밍함</p>
					</section>

					<section>
						<h2>Makefiles</h2>
						<p><small>대표적인 편찬기임</small></p>

						<pre><code 
						class="language-make" 
						data-trim data-noescape 
						data-line-numbers="|1-3|8-11|13-16|18-21|5-6|23-25|"
						>
							<script type="text/template">
								# 변환기의 별명을 짓는다.
								# gcc가 아닌 다른 변환기를 사용할 여지를 남기기
								CC = gcc 
								
								# out을 실행한다.
								all: out
								
								# main.c를 필요로 하는 스크립트
								# main.c.o를 만든다.
								main.c.o: main.c
									$(CC) -c main.c -o main.c.o

								# retz.c를 필요로 하는 스크립트
								# retz.c.o를 만든다.
								retz.c.o: retz.c
									$(CC) -c retz.c -o retz.c.o

								# main.c.o, retz.c.o를 필요로 하는 스크립트
								# out을 만든다.
								out: main.c.o retz.c.o
									$(CC) main.c.o retz.c.o -o out

								# 청소
								clean:
								rm -f main.c.o retz.c.o out
							</script>
						</code></pre>
					</section>

					<section>
						<h2>장점</h2>
						<ul>
							<li>`make` 하나로 명령어 통일 가능</li>
							<li>편찬 과정을 분리할 수 있음</li>
							<li>변수를 사용하여 사용할 도구를 결정할 수 있음</li>
						</ul>
					</section>

					<section>
						<h2>단점</h2>
						<ul>
							<li>사용할 수 있는 경로는 여전히 정해져 있음</li>
							<li>변환기는 여전히 직접 넣어 줘야 함</li>
						</ul>
					</section>
				</section>

				<section>
					<h2>그럼 이걸 어떻게 해결해야 하는가</h2>
				</section>
			</div>
		</div>
	</body>

	<script>
		Reveal.initialize({
			hash: true,
			controls: true,
			progress: true,
			center: true,
			slideNumber: 'c/t',
			transition: 'slide', 
			plugins: [ RevealHighlight, RevealNotes, RevealMath.KaTeX ]
		});
	</script>
</html>
